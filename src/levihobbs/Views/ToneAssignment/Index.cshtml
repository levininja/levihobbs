@model levihobbs.Models.ToneAssignmentViewModel
@{
    ViewData["Title"] = "Tone Assignment";
}

@section Styles {
    <link rel="stylesheet" href="~/css/tone-assignment.css" />
}

<!-- Banner Messages Container -->
<div id="bannerMessages" class="banner-messages"></div>

@section Scripts {
<script>
    // Global variables for tracking processing state
    let currentBatchId = null;
    let statusCheckInterval = null;
    let processingBookIds = [];
    let allTones = @Html.Raw(System.Text.Json.JsonSerializer.Serialize(Model.AllTones.Select(t => t.Name)));
    
    // Initialize Bootstrap tooltips
    document.addEventListener('DOMContentLoaded', function() {
        $('[data-toggle="tooltip"]').tooltip({
            html: true,
            placement: 'bottom',
            template: '<div class="tooltip" role="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner" style="max-width: 800px; width: 800px; font-size: 1rem;"></div></div>'
        });
        
        // Handle AI processing button click
        document.getElementById('sendForProcessing').addEventListener('click', function() {
            const batchSize = parseInt(document.getElementById('batchSize').value);
            const booksWithoutTones = @Html.Raw(System.Text.Json.JsonSerializer.Serialize(Model.BookReviews.Select(br => br.Id)));
            
            if (booksWithoutTones.length === 0) {
                showBannerMessage('No books without tone assignments available for processing.', 'warning');
                return;
            }
            
            const selectedBookIds = booksWithoutTones.slice(0, batchSize);
            
            // Grey out the first X rows
            greyOutProcessingRows(selectedBookIds);
            
            // Disable button during processing
            const button = this;
            const originalText = button.textContent;
            button.disabled = true;
            button.textContent = 'Processing...';
            
            // Make API call to process books
            const bookIdsParam = selectedBookIds.map(id => `bookIds=${id}`).join('&');
            
            fetch(`/api/BookToneRecommendationsProxy?${bookIdsParam}`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                }
            }).then(response => {
                if (response.ok) {
                    return response.json();
                } else {
                    throw new Error('Failed to send books for processing');
                }
            }).then(data => {
                currentBatchId = data.batchId;
                processingBookIds = selectedBookIds;
                
                showBannerMessage(`Successfully sent ${selectedBookIds.length} books for AI processing. Batch ID: ${data.batchId}`, 'info');
                
                // Start checking status every 15 minutes (900000 ms)
                statusCheckInterval = setInterval(() => {
                    checkBatchStatus(currentBatchId);
                }, 15000); // temporarily do 15 seconds
                
                // Check status immediately
                checkBatchStatus(currentBatchId);
            }).catch(error => {
                console.error('AI processing request failed:', error);
                showBannerMessage('Failed to send books for processing. Please try again.', 'error');
                
                // Re-enable the rows
                enableProcessingRows(selectedBookIds);
            }).finally(() => {
                // Re-enable button
                button.disabled = false;
                button.textContent = originalText;
            });
        });
    });
    
    function greyOutProcessingRows(bookIds) {
        bookIds.forEach(bookId => {
            const row = document.querySelector(`tr[data-book-id="${bookId}"]`);
            if (row)
                row.classList.add('processing-row');
        });
    }
    
    function enableProcessingRows(bookIds) {
        bookIds.forEach(bookId => {
            const row = document.querySelector(`tr[data-book-id="${bookId}"]`);
            if (row)
                row.classList.remove('processing-row');
        });
    }
    
    function checkBatchStatus(batchId) {
        fetch(`/api/BookToneRecommendationsProxy/batch/${batchId}/status`)
            .then(response => {
                if (response.ok)
                    return response.json();
                else
                    throw new Error('Failed to get batch status');
            })
            .then(data => {
                if (data.status === 'Processing') {
                    // Keep rows greyed out, no change to banner
                    return;
                } else if (data.status === 'Failed') {
                    // Enable rows and show error banner
                    enableProcessingRows(processingBookIds);
                    showBannerMessage(`Processing failed for books: ${processingBookIds.join(', ')}. Batch ID: ${batchId}`, 'error');
                    
                    // Clear interval
                    if (statusCheckInterval) {
                        clearInterval(statusCheckInterval);
                        statusCheckInterval = null;
                    }
                } else if (data.status === 'Completed') {
                    // Show success banner and get recommendations
                    showBannerMessage(`Successfully processed books: ${processingBookIds.join(', ')}`, 'success');
                    enableProcessingRows(processingBookIds);
                    
                    // Get recommendations for each book
                    processingBookIds.forEach(bookId => {
                        getBookRecommendations(bookId);
                    });
                    
                    // Clear interval
                    if (statusCheckInterval) {
                        clearInterval(statusCheckInterval);
                        statusCheckInterval = null;
                    }
                }
            })
            .catch(error => {
                console.error('Status check failed:', error);
            });
    }
    
    function getBookRecommendations(bookId) {
        fetch(`/api/BookToneRecommendationsProxy/${bookId}`)
            .then(response => {
                if (response.ok)
                    return response.json();
                else
                    throw new Error('Failed to get recommendations');
            })
            .then(data => {
                if (data && data.length > 0)
                    addRecommendationsToBook(bookId, data);
            })
            .catch(error => {
                console.error('Failed to get recommendations for book', bookId, error);
            });
    }
    
    function addRecommendationsToBook(bookId, recommendations) {
        const suggestionsColumn = document.querySelector(`tr[data-book-id="${bookId}"] .suggestions-column`);
        if (!suggestionsColumn) {
            showBannerMessage(`Error: Could not find suggestions column for book ID ${bookId}`, 'error');
            return;
        }
        
        recommendations.forEach(rec => {
            const toneName = rec.tone;
            const isApprovedTone = allTones.includes(toneName);
            
            const toneTag = document.createElement('span');
            toneTag.className = `tone-tag ai-recommendation ${isApprovedTone ? '' : 'not-approved'}`;
            toneTag.setAttribute('data-recommendation-id', rec.id);
            toneTag.setAttribute('data-book-id', bookId);
            toneTag.setAttribute('data-tone-name', toneName);
            
            if (isApprovedTone)
                toneTag.onclick = () => applySuggestion(bookId, toneName);
            
            toneTag.innerHTML = `
                ${toneName}
                <button class="thumbs-down-btn" onclick="giveFeedback(${rec.id}, event, false)">
                    ðŸ‘Ž
                </button>
            `;
            
            suggestionsColumn.appendChild(toneTag);
        });
    }
    
    function giveFeedback(recommendationId, event, isPositive = false) {
        if (event)
            event.stopPropagation();
        
        const feedbackValue = isPositive ? 1 : -1;
        const feedbackData = {
            toneId: recommendationId,
            feedback: feedbackValue
        };
        
        fetch(`/api/BookToneRecommendationsProxy/${recommendationId}`, {
            method: 'PUT',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(feedbackData)
        }).then(response => {
            if (response.ok) {
                if (event) {
                    // Mark the recommendation as feedback given
                    const toneTag = event.target.closest('.tone-tag');
                    toneTag.classList.add('feedback-given');
                    event.target.classList.add('disabled');
                }
                
                showBannerMessage('Feedback successfully recorded', 'success');
            } else {
                showBannerMessage('Failed to record feedback', 'error');
            }
        }).catch(error => {
            console.error('Feedback request failed:', error);
            showBannerMessage('Failed to record feedback', 'error');
        });
    }
    
    function showBannerMessage(message, type) {
        const bannerContainer = document.getElementById('bannerMessages');
        const banner = document.createElement('div');
        banner.className = `banner-message ${type}`;
        
        const messageId = 'banner-' + Date.now();
        banner.id = messageId;
        
        banner.innerHTML = `
            <span>${message}</span>
            <button class="banner-close" onclick="closeBanner('${messageId}')">&times;</button>
        `;
        
        bannerContainer.appendChild(banner);
    }
    
    function closeBanner(bannerId) {
        const banner = document.getElementById(bannerId);
        if (banner)
            banner.remove();
    }

    function toggleTone(bookReviewId, toneId, element) {
        const isSelected = element.classList.contains('selected');
        const hiddenInput = document.querySelector(`input[name="BookReviews[${getBookReviewIndex(bookReviewId)}].AssignedToneIds"][value="${toneId}"], input[name="BooksWithTones[${getBooksWithTonesIndex(bookReviewId)}].AssignedToneIds"][value="${toneId}"]`);
        
        if (isSelected) {
            element.classList.remove('selected');
            if (hiddenInput) {
                hiddenInput.remove();
            }
            // Remove from selected tones display
            removeToneFromSelectedDisplay(bookReviewId, toneId);
        } else {
            element.classList.add('selected');
            if (!hiddenInput) {
                const input = document.createElement('input');
                input.type = 'hidden';
                
                // Determine if this is in the main table or the accordion table
                const bookReviewIndex = getBookReviewIndex(bookReviewId);
                const booksWithTonesIndex = getBooksWithTonesIndex(bookReviewId);
                
                if (bookReviewIndex !== -1) {
                    input.name = `BookReviews[${bookReviewIndex}].AssignedToneIds`;
                } else if (booksWithTonesIndex !== -1) {
                    input.name = `BooksWithTones[${booksWithTonesIndex}].AssignedToneIds`;
                }
                
                input.value = toneId;
                document.getElementById(`book-${bookReviewId}-inputs`).appendChild(input);
            }
            // Add to selected tones display
            addToneToSelectedDisplay(bookReviewId, toneId, element);
        }
    }
    
    function getBookReviewIndex(bookReviewId) {
        const bookReviews = @Html.Raw(System.Text.Json.JsonSerializer.Serialize(Model.BookReviews.Select(br => br.Id)));
        return bookReviews.indexOf(bookReviewId);
    }
    
    function getBooksWithTonesIndex(bookReviewId) {
        const booksWithTones = @Html.Raw(System.Text.Json.JsonSerializer.Serialize(Model.BooksWithTones.Select(br => br.Id)));
        return booksWithTones.indexOf(bookReviewId);
    }
    
    function applySuggestion(bookReviewId, toneName) {
        // AI recommendation - find the tone by name
        const toneElement = document.querySelector(`[data-book="${bookReviewId}"][data-tone-name="${toneName}"]`);
        if (toneElement && !toneElement.classList.contains('selected')) {
            // Find the actual tone ID from the tone groups
            const toneGroups = @Html.Raw(System.Text.Json.JsonSerializer.Serialize(Model.ToneColorGroupings.Select(g => new { g.Name, g.ColorClass, Tones = g.Tones.Select(t => new { t.Id, t.Name }) })));
            let foundToneId = null;
            
            for (const group of toneGroups) {
                const tone = group.Tones.find(t => t.Name === toneName);
                if (tone) {
                    foundToneId = tone.Id;
                    break;
                }
            }
            
            if (foundToneId) {
                toggleTone(bookReviewId, foundToneId, toneElement);
                
                // Give positive feedback when recommendation is applied
                const recommendationId = toneElement.getAttribute('data-recommendation-id');
                if (recommendationId)
                    giveFeedback(parseInt(recommendationId), null, true);
            }
        }
    }
    
    function applyAllSuggestions(bookReviewId) {
        const suggestionElements = document.querySelectorAll(`[data-book="${bookReviewId}"].suggested`);
        suggestionElements.forEach(element => {
            const toneId = element.getAttribute('data-tone');
            applySuggestion(bookReviewId, parseInt(toneId));
        });
    }
    
    function addToneToSelectedDisplay(bookReviewId, toneId, element) {
        const selectedTonesSection = document.querySelector(`#book-${bookReviewId}-inputs`).closest('td').querySelector('.selected-tones');
        const selectedTonesContainer = selectedTonesSection.querySelector('.selected-tones-list');
        const toneName = element.textContent.trim();
        
        // Find the correct color class by looking for the tone in the tone groups
        let colorClass = Array.from(element.classList).find(cls => cls.startsWith('tone-') && cls !== 'tone-tag');
        if (!colorClass || colorClass === 'tone-other') {
            // If we can't find a proper color class or it's tone-other, find the correct one
            const toneGroups = @Html.Raw(System.Text.Json.JsonSerializer.Serialize(Model.ToneColorGroupings.Select(g => new { g.Name, g.ColorClass, Tones = g.Tones.Select(t => new { t.Id, t.Name }) })));
            for (const group of toneGroups) {
                if (group.Tones.some(t => t.Id === toneId)) {
                    colorClass = group.ColorClass;
                    break;
                }
            }
        }
        
        // Show the section if it's hidden
        selectedTonesSection.style.display = 'block';
        
        // Check if tone is already in the display
        const existingTone = selectedTonesContainer.querySelector(`[data-tone-id="${toneId}"]`);
        if (!existingTone) {
            const toneTag = document.createElement('span');
            toneTag.className = `tone-tag ${colorClass} selected removable`;
            toneTag.setAttribute('data-tone-id', toneId);
            toneTag.setAttribute('data-book-id', bookReviewId);
            toneTag.onclick = () => removeToneAssignment(bookReviewId, toneId);
            toneTag.innerHTML = `${toneName}<span class="remove-tone-x">&times;</span>`;
            selectedTonesContainer.appendChild(toneTag);
        }
    }
    
    function removeToneFromSelectedDisplay(bookReviewId, toneId) {
        const selectedTonesSection = document.querySelector(`#book-${bookReviewId}-inputs`).closest('td').querySelector('.selected-tones');
        const selectedTonesContainer = selectedTonesSection.querySelector('.selected-tones-list');
        const toneElement = selectedTonesContainer.querySelector(`[data-tone-id="${toneId}"]`);
        if (toneElement) {
            toneElement.remove();
            
            // If no more selected tones, hide the entire section
            if (selectedTonesContainer.children.length === 0) {
                selectedTonesSection.style.display = 'none';
            }
        }
    }
    
    function removeToneAssignment(bookReviewId, toneId) {
        // Remove the tone from the selected display
        removeToneFromSelectedDisplay(bookReviewId, toneId);
        
        // Remove the hidden input for this tone
        const hiddenInput = document.querySelector(`input[name="BookReviews[${getBookReviewIndex(bookReviewId)}].AssignedToneIds"][value="${toneId}"], input[name="BooksWithTones[${getBooksWithTonesIndex(bookReviewId)}].AssignedToneIds"][value="${toneId}"]`);
        if (hiddenInput) {
            hiddenInput.remove();
        }
        
        // Remove the selected class from the tone tag in the tone columns
        const toneElement = document.querySelector(`[data-book="${bookReviewId}"][data-tone="${toneId}"]`);
        if (toneElement) {
            toneElement.classList.remove('selected');
        }
    }

</script>
}

<div class="container-fluid">
    <h1>Tone Assignment</h1>
    
    <div class="batch-processing-section mb-4">
        <h4>AI Tone Recommendations</h4>
        <div class="form-inline">
            <label for="batchSize" class="mr-2">Number of books to process:</label>
            <input type="number" id="batchSize" class="form-control mr-2 batch-size-input" min="1" max="10" value="1">
            <button type="button" id="sendForProcessing" class="btn btn-info">Send for AI Processing</button>
        </div>
        <small class="form-text text-muted">Send the top X books to AI to generate tone recommendations.</small>
    </div>
    
    @if (TempData["SuccessMessage"] != null)
    {
        <div class="alert alert-success">@TempData["SuccessMessage"]</div>
    }
    
    @if (TempData["ErrorMessage"] != null)
    {
        <div class="alert alert-danger">@TempData["ErrorMessage"]</div>
    }
    
    @if (!ViewData.ModelState.IsValid)
    {
        <div class="alert alert-danger">
            @foreach (var error in ViewData.ModelState.Values.SelectMany(v => v.Errors))
            {
                <div>@error.ErrorMessage</div>
            }
        </div>
    }
    
    <form asp-action="Update" method="post">
        <!-- Books Without Tones Section -->
        <div class="section-title">Books Without Tones Assigned Yet</div>
        
        @if (Model.BookReviews.Any())
        {
            @await Html.PartialAsync("_ToneAssignmentTable", new ViewDataDictionary(ViewData) { 
                { "BookReviews", Model.BookReviews }, 
                { "ToneColorGroupings", Model.ToneColorGroupings },
                { "InputPrefix", "BookReviews" }
            })
        }
        else
        {
            <div class="alert alert-info">All books with review content have been assigned tones!</div>
        }
        
        <!-- Books With Tones Section (Accordion) -->
        @if (Model.BooksWithTones.Any())
        {
            <div class="panel-group mt-4" id="booksWithTonesAccordion">
                <div class="panel panel-default">
                    <div class="panel-heading" id="booksWithTonesHeading">
                        <h4 class="panel-title">
                            <a class="accordion-toggle" data-toggle="collapse" data-parent="#booksWithTonesAccordion" href="#booksWithTonesCollapse">
                                Books Already Assigned Tones (@Model.BooksWithTones.Count)
                            </a>
                        </h4>
                    </div>
                    <div id="booksWithTonesCollapse" class="panel-collapse collapse" aria-labelledby="booksWithTonesHeading">
                        <div class="panel-body">
                            @await Html.PartialAsync("_ToneAssignmentTable", new ViewDataDictionary(ViewData) { 
                                { "BookReviews", Model.BooksWithTones }, 
                                { "ToneColorGroupings", Model.ToneColorGroupings },
                                { "InputPrefix", "BooksWithTones" }
                            })
                        </div>
                    </div>
                </div>
            </div>
        }
        
        <div class="save-section">
            <button type="submit" class="btn btn-primary">Save Tone Assignments</button>
            <a href="@Url.Action("Index")" class="btn btn-secondary">Cancel</a>
        </div>
    </form>
</div>